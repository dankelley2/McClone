using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace VoxelGame
{
    // Moved from World.cs
    public class Chunk : IDisposable
    {
        public const int ChunkSize = 16; // Size of chunk in X and Z dimensions
        public const int ChunkHeight = 128; // Max height of a chunk column

        public Vector2i ChunkCoords { get; } // (ChunkX, ChunkZ)
        public Vector3i WorldOffset { get; } // (ChunkX * ChunkSize, 0, ChunkZ * ChunkSize)

        // Compressed voxel storage: one 2D array per Y layer, null if empty
        // Allow nulls for empty layers
        private byte[,]?[] _layers = new byte[ChunkHeight][,];

        private int _vao = 0;
        private int _vbo = 0;
        private int _vertexCount = 0;
        private volatile bool _isDirty = true; // Needs buffer rebuild (volatile for thread safety)
        internal volatile bool _isGenerating = false; // volatile for thread safety
        internal volatile bool _isInitialized = false; // volatile for thread safety
        public List<float>? PendingVertexData { get; set; } // Stores data generated by background thread

        private readonly World _parentWorld; // Reference to parent world for noise, etc.

        public Chunk(Vector2i coords, World parentWorld)
        {
            ChunkCoords = coords;
            WorldOffset = new Vector3i(ChunkCoords.X * ChunkSize, 0, ChunkCoords.Y * ChunkSize);
            _parentWorld = parentWorld;
        }

        // Updated IsReadyToDraw check - Draw if initialized and buffers exist
        public bool IsReadyToDraw => _isInitialized && _vao != 0;
        internal bool IsDirty => _isDirty; // Keep internal getter

        // Get all non-air voxel positions by Y (for collision)
        internal IEnumerable<(byte y, List<(byte x, byte z)>)> GetVoxelPositionsByY()
        {
            for (byte y = 0; y < ChunkHeight; y++)
            {
                var layer = _layers[y];
                if (layer == null) continue;
                List<(byte x, byte z)>? positions = null;
                for (byte x = 0; x < ChunkSize; x++)
                {
                    for (byte z = 0; z < ChunkSize; z++)
                    {
                        if (layer[x, z] != 0)
                        {
                            positions ??= new List<(byte x, byte z)>();
                            positions.Add((x, z));
                        }
                    }
                }
                if (positions != null)
                    yield return (y, positions);
            }
        }

        // Generates terrain data for this chunk (Called from background thread)
        public void GenerateTerrain()
        {
            // Simple check first, then lock for finer-grained control
            if (_isInitialized || _isGenerating) return;

            lock (this) // Lock the chunk instance during generation
            {
                // Double-check inside lock
                if (_isInitialized || _isGenerating) return;
                _isGenerating = true;
            }

            try
            {
                for (int y = 0; y < ChunkHeight; y++)
                    _layers[y] = null;

                for (int x = 0; x < ChunkSize; x++)
                {
                    for (int z = 0; z < ChunkSize; z++)
                    {
                        double noiseValue = _parentWorld.GetNoiseValue(WorldOffset.X + x, WorldOffset.Z + z);
                        byte height = (byte)Math.Max(byte.MinValue, Math.Min(byte.MaxValue, World.BaseHeight + Math.Round((noiseValue + 1.0) / 2.0 * World.TerrainAmplitude)));
                        
                        for (byte y = World.BaseHeight - 1; y <= height && y < ChunkHeight; y++){
                            byte[,]? currentLayer = _layers[y]; // Assign to nullable local var
                            if (currentLayer == null)
                            {
                                currentLayer = new byte[ChunkSize, ChunkSize];
                                _layers[y] = currentLayer; // Assign back to the array
                            }
                            // Now the compiler knows currentLayer is not null here
                            currentLayer[x, z] = 1; // 1 = solid voxel
                        }
                    }
                }
            }
            finally // Ensure flags are reset even if an error occurs
            {
                // No lock needed for volatile writes if atomicity isn't required across multiple fields
                _isDirty = true; // Mark for buffer update (main thread will handle)
                _isGenerating = false;
                _isInitialized = true; // Mark as generated
            }
        }

        public static (byte X, byte Z) VoxelIndexToCoords(byte index)
        {
            byte x = (byte)(index % ChunkSize);
            byte z = (byte)(index / ChunkSize);
            return new(x, z);
        }

        // Public method to get the state of a voxel at local coordinates
        // Returns 0 for air/out-of-bounds, >0 for solid types
        public byte GetLocalVoxelState(int x, int y, int z)
        {
            // Check bounds first
            if (y < 0 || y >= ChunkHeight || x < 0 || x >= ChunkSize || z < 0 || z >= ChunkSize)
            {
                return 0; // Outside chunk bounds is air
            }

            // Check if the layer exists
            var layer = _layers[y];
            if (layer == null)
            {
                return 0; // Null layer means air
            }

            // Return the voxel state (e.g., 1 for solid, 0 for air)
            return layer[x, z];
        }

        // Helper: Checks if a voxel at the given *local* chunk coordinates is solid.
        // Handles boundary checks and null layers.
        // Note: This is now less used externally, GetLocalVoxelState is preferred for world checks.
        private bool IsVoxelSolid(int x, int y, int z)
        {
            return GetLocalVoxelState(x, y, z) != 0;
        }

        // Helper: Checks if a voxel at (x, y, z) has an exposed face and returns which faces are exposed
        // Face order MUST match CubeData.Vertices: 0=+Z, 1=-Z, 2=-X, 3=+X, 4=-Y, 5=+Y
        private List<int> GetExposedFaces(byte x, byte y, byte z)
        {
            var exposedFaces = new List<int>();
            (int dx, int dy, int dz)[] directions = new (int, int, int)[] {
                ( 0,  0,  1),  // Front (+Z) -> Index 0
                ( 0,  0, -1),  // Back (-Z)  -> Index 1
                (-1,  0,  0),  // Left (-X)  -> Index 2
                ( 1,  0,  0),  // Right (+X) -> Index 3
                ( 0, -1,  0),  // Bottom (-Y)-> Index 4
                ( 0,  1,  0)   // Top (+Y)   -> Index 5
            };

            for (int d = 0; d < directions.Length; d++)
            {
                int nx = x + directions[d].dx;
                int ny = y + directions[d].dy;
                int nz = z + directions[d].dz;

                // Use the helper function to check the neighbor
                // If the neighbor voxel is NOT solid, then this face 'd' is exposed.
                if (!IsVoxelSolid(nx, ny, nz))
                {
                    exposedFaces.Add(d);
                }
            }
            return exposedFaces;
        }

        // Helper: Adds the mesh data for a single voxel's exposed faces
        private void AddVoxelMeshData(List<float> vertexData, byte x, byte y, byte z, List<int> exposedFaces, float[] cubeVertices, int vertexStride)
        {
            // Calculate the integer world coordinates of the block's corner
            int worldCornerX = WorldOffset.X + x;
            int worldCornerY = y;
            int worldCornerZ = WorldOffset.Z + z;

            foreach (int d in exposedFaces)
            {
                int faceStart = d * 6 * vertexStride;
                for (int j = 0; j < 6 * vertexStride; j += vertexStride)
                {
                    // Add base vertex position (centered around 0,0,0) + 0.5 offset + integer world corner
                    vertexData.Add(cubeVertices[faceStart + j + 0] + 0.5f + worldCornerX);
                    vertexData.Add(cubeVertices[faceStart + j + 1] + 0.5f + worldCornerY);
                    vertexData.Add(cubeVertices[faceStart + j + 2] + 0.5f + worldCornerZ);
                    vertexData.Add(cubeVertices[faceStart + j + 3]);
                    vertexData.Add(cubeVertices[faceStart + j + 4]);
                    vertexData.Add(cubeVertices[faceStart + j + 5]);
                    vertexData.Add(cubeVertices[faceStart + j + 6]);
                    vertexData.Add(cubeVertices[faceStart + j + 7]);
                }
            }
        }

        // Public method to mark the chunk as dirty, forcing a mesh rebuild
        public void MarkDirty()
        {
            _isDirty = true;
        }

        // Removes a block at the specified local chunk coordinates
        public void RemoveBlock(byte x, byte y, byte z)
        {
            // Check bounds
            if (y >= ChunkHeight || x >= ChunkSize || z >= ChunkSize)
            {
                Console.WriteLine($"Warning: Attempted to remove block outside chunk bounds at ({x},{y},{z})");
                return;
            }

            // Check if the layer exists and the block is actually solid
            var layer = _layers[y];
            if (layer != null && layer[x, z] != 0)
            {
                layer[x, z] = 0; // Set to air
                _isDirty = true; // Mark chunk for mesh regeneration

                // Optional: Check if layer is now empty and set _layers[y] = null
                // This adds complexity but saves memory if layers become fully empty.
                bool layerEmpty = true;
                for (int checkX = 0; checkX < ChunkSize; checkX++){
                    for (int checkZ = 0; checkZ < ChunkSize; checkZ++){
                        if(layer[checkX, checkZ] != 0) { layerEmpty = false; break; }
                    }
                    if (!layerEmpty) break;
                }
                if (layerEmpty) _layers[y] = null;

                // TODO: Consider notifying neighboring chunks if the removed block was on a border
                // This would require accessing the World object and marking neighbors as dirty.
            }
            // If layer is null or block is already 0, do nothing.
        }

        // Generates vertex data based on current voxel state (Thread Safe)
        public List<float> GenerateVertexData()
        {
            if (!_isInitialized) return new List<float>();

            List<float> vertexData = new List<float>();
            float[] cubeVertices = CubeData.Vertices; // Static data, safe
            int vertexStride = CubeData.VertexStride; // Static data, safe

            for (byte y = 0; y < ChunkHeight; y++)
            {
                var layer = _layers[y]; // layer is now potentially null
                if (layer == null) continue;

                for (byte x = 0; x < ChunkSize; x++)
                {
                    for (byte z = 0; z < ChunkSize; z++)
                    {
                        if (layer[x, z] == 0) continue;

                        var exposedFaces = GetExposedFaces(x, y, z);
                        if (exposedFaces.Count > 0)
                        {
                            AddVoxelMeshData(vertexData, x, y, z, exposedFaces, cubeVertices, vertexStride);
                        }
                    }
                }
            }
            return vertexData;
        }

        // Renamed from SetupBuffers - Only handles GL buffer operations (Main Thread)
        public void UpdateGLBuffers(List<float> vertexData)
        {
            if (!_isInitialized) return;

            _vertexCount = vertexData.Count / CubeData.VertexStride;

            if (_vertexCount == 0)
            {
                DisposeBuffers();
                _isDirty = false;
                return;
            }

            if (_vao == 0) _vao = GL.GenVertexArray();
            GL.BindVertexArray(_vao);

            if (_vbo == 0) _vbo = GL.GenBuffer();
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vbo);
            GL.BufferData(BufferTarget.ArrayBuffer, vertexData.Count * sizeof(float), vertexData.ToArray(), BufferUsageHint.StaticDraw);

            int strideBytes = CubeData.VertexStride * sizeof(float); // Now 8 * 4 = 32 bytes

            // Position attribute (location = 0)
            GL.EnableVertexAttribArray(0);
            // 3 floats, starting at offset 0
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, strideBytes, 0);

            // Normal attribute (location = 1)
            GL.EnableVertexAttribArray(1);
            // 3 floats, starting after Position (3 floats), so offset is 3 * sizeof(float)
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, false, strideBytes, 3 * sizeof(float)); // Corrected offset

            // TexCoord attribute (location = 2)
            GL.EnableVertexAttribArray(2);
            // 2 floats, starting after Position (3) and Normal (3), so offset is 6 * sizeof(float)
            GL.VertexAttribPointer(2, 2, VertexAttribPointerType.Float, false, strideBytes, 6 * sizeof(float)); // Corrected offset

            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);

            _isDirty = false;
        }

        // Draw method (MUST be called from the main/OpenGL thread)
        public void Draw()
        {
            if (!IsReadyToDraw) return;

            GL.BindVertexArray(_vao);
            GL.DrawArrays(PrimitiveType.Triangles, 0, _vertexCount);
            GL.BindVertexArray(0);
        }

        // Dispose OpenGL buffers (MUST be called from the main/OpenGL thread)
        private void DisposeBuffers()
        {
            if (_vbo != 0)
            {
                GL.DeleteBuffer(_vbo);
                _vbo = 0;
            }
            if (_vao != 0)
            {
                GL.DeleteVertexArray(_vao);
                _vao = 0;
            }
            _vertexCount = 0;
            _isInitialized = false;
            _isDirty = true;
        }

        // Dispose method (MUST be called from the main/OpenGL thread)
        public void Dispose()
        {
            DisposeBuffers();
        }
    }
}
