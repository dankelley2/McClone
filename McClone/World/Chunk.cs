using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace VoxelGame.World
{
    // Moved from World.cs
    public class Chunk : IDisposable
    {
        public const int ChunkSize = 16; // Size of chunk in X and Z dimensions
        public const int ChunkHeight = 128; // Max height of a chunk column

        public Vector2i ChunkCoords { get; } // (ChunkX, ChunkZ)
        public Vector3i WorldOffset { get; } // (ChunkX * ChunkSize, 0, ChunkZ * ChunkSize)

        // Compressed voxel storage: one 2D array per Y layer, null if empty
        // Allow nulls for empty layers
        private byte[,]?[] _layers = new byte[ChunkHeight][,];

        private int _vao = 0;
        private int _vbo = 0;
        private int _vertexCount = 0;
        private volatile bool _isDirty = true; // Needs buffer rebuild (volatile for thread safety)
        internal volatile bool _isGenerating = false; // volatile for thread safety
        internal volatile bool _isInitialized = false; // volatile for thread safety
        public List<float>? PendingVertexData { get; set; } // Stores data generated by background thread

        private readonly World _parentWorld; // Reference to parent world for noise, etc.

        public Chunk(Vector2i coords, World parentWorld)
        {
            ChunkCoords = coords;
            WorldOffset = new Vector3i(ChunkCoords.X * ChunkSize, 0, ChunkCoords.Y * ChunkSize);
            _parentWorld = parentWorld;
        }

        // Updated IsReadyToDraw check - Draw if initialized and buffers exist
        public bool IsReadyToDraw => _isInitialized && _vao != 0;
        internal bool IsDirty => _isDirty; // Keep internal getter

        // Get all non-air voxel positions by Y (for collision)
        internal IEnumerable<(byte y, List<(byte x, byte z)>)> GetVoxelPositionsByY()
        {
            for (byte y = 0; y < ChunkHeight; y++)
            {
                var layer = _layers[y];
                if (layer == null) continue;
                List<(byte x, byte z)>? positions = null;
                for (byte x = 0; x < ChunkSize; x++)
                {
                    for (byte z = 0; z < ChunkSize; z++)
                    {
                        if (layer[x, z] != 0)
                        {
                            positions ??= new List<(byte x, byte z)>();
                            positions.Add((x, z));
                        }
                    }
                }
                if (positions != null)
                    yield return (y, positions);
            }
        }

        // Generates terrain data for this chunk (Called from background thread)
        public void GenerateTerrain()
        {
            // Simple check first, then lock for finer-grained control
            if (_isInitialized || _isGenerating) return;

            lock (this) // Lock the chunk instance during generation
            {
                // Double-check inside lock
                if (_isInitialized || _isGenerating) return;
                _isGenerating = true;
            }

            try
            {
                // --- Base Terrain Generation ---
                for (int y = 0; y < ChunkHeight; y++)
                    _layers[y] = null;

                for (int x = 0; x < ChunkSize; x++)
                {
                    for (int z = 0; z < ChunkSize; z++)
                    {
                        // Access constants via _parentWorld._worldGen
                        double noiseValue = _parentWorld.GetNoiseValue(WorldOffset.X + x, WorldOffset.Z + z);
                        byte height = (byte)Math.Max(byte.MinValue, Math.Min(byte.MaxValue, WorldGeneration.BaseHeight + Math.Round((noiseValue + 1.0) / 2.0 * WorldGeneration.TerrainAmplitude)));

                        for (byte y = (byte)(WorldGeneration.BaseHeight - 1); y <= height && y < ChunkHeight; y++){
                            // Use internal setter to handle layer creation
                            SetLocalVoxelStateInternal((byte)x, y, (byte)z, 1); // 1 = solid voxel
                        }
                    }
                }

                // --- Apply Persistent Edits ---
                ChunkEdits? edits = ChunkEdits.GetEdits(this.ChunkCoords);
                if (edits != null)
                {
                    edits.ApplyToChunk(this);
                    // ApplyToChunk already marks the chunk dirty if edits were applied
                }

            }
            finally // Ensure flags are reset even if an error occurs
            {
                // No lock needed for volatile writes if atomicity isn't required across multiple fields
                _isDirty = true; // Mark for buffer update (main thread will handle) - ApplyToChunk might also set this
                _isGenerating = false;
                _isInitialized = true; // Mark as generated
            }
        }

        public static (byte X, byte Z) VoxelIndexToCoords(byte index)
        {
            byte x = (byte)(index % ChunkSize);
            byte z = (byte)(index / ChunkSize);
            return new(x, z);
        }

        // Internal method to set voxel state, handles layer creation. Used by GenerateTerrain and ChunkEdits.ApplyToChunk
        internal void SetLocalVoxelStateInternal(byte x, int y, byte z, byte state)
        {
            // Bounds check (redundant if called carefully, but safe)
            if (y < 0 || y >= ChunkHeight || x >= ChunkSize || z >= ChunkSize)
            {
                return;
            }

            // Get or create the layer
            byte[,]? currentLayer = _layers[y];
            if (currentLayer == null)
            {
                // Only create a new layer if the state is non-air
                if (state != 0)
                {
                    currentLayer = new byte[ChunkSize, ChunkSize];
                    _layers[y] = currentLayer;
                }
                else
                {
                    // Trying to set air in a non-existent (implicitly air) layer, do nothing
                    return;
                }
            }

            // Set the state
            currentLayer[x, z] = state;

            // Optional: Check if layer becomes empty after setting state to 0
            if (state == 0)
            {
                bool layerEmpty = true;
                for (int checkX = 0; checkX < ChunkSize; checkX++)
                {
                    for (int checkZ = 0; checkZ < ChunkSize; checkZ++)
                    {
                        if (currentLayer[checkX, checkZ] != 0) { layerEmpty = false; break; }
                    }
                    if (!layerEmpty) break;
                }
                if (layerEmpty) _layers[y] = null; // Deallocate empty layer
            }
        }


        // Public method to get the state of a voxel at local coordinates
        // Returns 0 for air/out-of-bounds, >0 for solid types
        public byte GetLocalVoxelState(int x, int y, int z)
        {
            // Check bounds first
            if (y < 0 || y >= ChunkHeight || x < 0 || x >= ChunkSize || z < 0 || z >= ChunkSize)
            {
                return 0; // Outside chunk bounds is air
            }

            // Check if the layer exists
            var layer = _layers[y];
            if (layer == null)
            {
                return 0; // Null layer means air
            }

            // Return the voxel state (e.g., 1 for solid, 0 for air)
            return layer[x, z];
        }

        // Helper: Checks if a voxel at the given *local* chunk coordinates is solid.
        // Handles boundary checks and null layers.
        // Note: This is now less used externally, GetLocalVoxelState is preferred for world checks.
        private bool IsVoxelSolid(int x, int y, int z)
        {
            return GetLocalVoxelState(x, y, z) != 0;
        }

        // Helper: Checks if a voxel at (x, y, z) has an exposed face and returns which faces are exposed
        // Face order MUST match CubeData.Vertices: 0=+Z, 1=-Z, 2=-X, 3=+X, 4=-Y, 5=+Y
        private List<int> GetExposedFaces(byte x, byte y, byte z)
        {
            var exposedFaces = new List<int>();
            (int dx, int dy, int dz)[] directions = new (int, int, int)[] {
                ( 0,  0,  1),  // Front (+Z) -> Index 0
                ( 0,  0, -1),  // Back (-Z)  -> Index 1
                (-1,  0,  0),  // Left (-X)  -> Index 2
                ( 1,  0,  0),  // Right (+X) -> Index 3
                ( 0, -1,  0),  // Bottom (-Y)-> Index 4
                ( 0,  1,  0)   // Top (+Y)   -> Index 5
            };

            for (int d = 0; d < directions.Length; d++)
            {
                int nx = x + directions[d].dx;
                int ny = y + directions[d].dy;
                int nz = z + directions[d].dz;

                // Use the helper function to check the neighbor
                // If the neighbor voxel is NOT solid, then this face 'd' is exposed.
                if (!IsVoxelSolid(nx, ny, nz))
                {
                    exposedFaces.Add(d);
                }
            }
            return exposedFaces;
        }

        // Helper: Adds the mesh data for a single voxel's exposed faces
        private void AddVoxelMeshData(List<float> vertexData, byte x, byte y, byte z, List<int> exposedFaces, float[] cubeVertices, int vertexStride)
        {
            // Calculate the integer world coordinates of the block's corner
            int worldCornerX = WorldOffset.X + x;
            int worldCornerY = y;
            int worldCornerZ = WorldOffset.Z + z;

            foreach (int d in exposedFaces)
            {
                int faceStart = d * 6 * vertexStride;
                for (int j = 0; j < 6 * vertexStride; j += vertexStride)
                {
                    // Add base vertex position (centered around 0,0,0) + 0.5 offset + integer world corner
                    vertexData.Add(cubeVertices[faceStart + j + 0] + 0.5f + worldCornerX);
                    vertexData.Add(cubeVertices[faceStart + j + 1] + 0.5f + worldCornerY);
                    vertexData.Add(cubeVertices[faceStart + j + 2] + 0.5f + worldCornerZ);
                    vertexData.Add(cubeVertices[faceStart + j + 3]);
                    vertexData.Add(cubeVertices[faceStart + j + 4]);
                    vertexData.Add(cubeVertices[faceStart + j + 5]);
                    vertexData.Add(cubeVertices[faceStart + j + 6]);
                    vertexData.Add(cubeVertices[faceStart + j + 7]);
                }
            }
        }

        // Public method to mark the chunk as dirty, forcing a mesh rebuild
        public void MarkDirty()
        {
            _isDirty = true;
        }

        // Removes a block at the specified local chunk coordinates
        public void RemoveBlock(byte x, byte y, byte z)
        {
            // Check bounds
            if (y >= ChunkHeight || x >= ChunkSize || z >= ChunkSize)
            {
                Console.WriteLine($"Warning: Attempted to remove block outside chunk bounds at ({x},{y},{z})");
                return;
            }

            // Check if the layer exists and the block is actually solid
            var layer = _layers[y];
            byte previousState = layer?[x, z] ?? 0; // Get previous state (0 if layer is null)

            if (previousState != 0) // Only proceed if it was a solid block
            {
                // Use internal setter to handle potential layer deallocation
                SetLocalVoxelStateInternal(x, y, z, 0); // Set to air

                // Record the edit persistently
                ChunkEdits.RecordEdit(this.ChunkCoords, y, x, z, 0); // Record setting to air

                _isDirty = true; // Mark chunk for mesh regeneration
            }
            // If layer is null or block is already 0, do nothing.
        }

        // Adds a block at the specified local chunk coordinates with the given state
        public void AddBlock(byte x, byte y, byte z, byte newState)
        {
            // Check bounds
            if (y >= ChunkHeight || x >= ChunkSize || z >= ChunkSize)
            {
                Console.WriteLine($"Warning: Attempted to add block outside chunk bounds at ({x},{y},{z})");
                return;
            }

            // Check if trying to add air (which is effectively removal)
            if (newState == 0)
            {
                RemoveBlock(x, y, z); // Delegate to RemoveBlock logic
                return;
            }

            // Check if a block already exists here
            byte previousState = GetLocalVoxelState(x, y, z);

            if (previousState != newState) // Only proceed if the state is actually changing
            {
                // Use internal setter to handle layer creation/update
                SetLocalVoxelStateInternal(x, y, z, newState);

                // Record the edit persistently
                ChunkEdits.RecordEdit(this.ChunkCoords, y, x, z, newState);

                _isDirty = true; // Mark chunk for mesh regeneration
            }
            // If the block state is already the desired newState, do nothing.
        }

        // Generates vertex data based on current voxel state (Thread Safe)
        public List<float> GenerateVertexData()
        {
            if (!_isInitialized) return new List<float>();

            List<float> vertexData = new List<float>();
            float[] cubeVertices = CubeData.Vertices; // Static data, safe
            int vertexStride = CubeData.VertexStride; // Static data, safe

            for (byte y = 0; y < ChunkHeight; y++)
            {
                var layer = _layers[y]; // layer is now potentially null
                if (layer == null) continue;

                for (byte x = 0; x < ChunkSize; x++)
                {
                    for (byte z = 0; z < ChunkSize; z++)
                    {
                        if (layer[x, z] == 0) continue;

                        var exposedFaces = GetExposedFaces(x, y, z);
                        if (exposedFaces.Count > 0)
                        {
                            AddVoxelMeshData(vertexData, x, y, z, exposedFaces, cubeVertices, vertexStride);
                        }
                    }
                }
            }
            return vertexData;
        }

        // Renamed from SetupBuffers - Only handles GL buffer operations (Main Thread)
        public void UpdateGLBuffers(List<float> vertexData)
        {
            if (!_isInitialized) return;

            _vertexCount = vertexData.Count / CubeData.VertexStride;

            if (_vertexCount == 0)
            {
                DisposeBuffers();
                _isDirty = false;
                return;
            }

            if (_vao == 0) _vao = GL.GenVertexArray();
            GL.BindVertexArray(_vao);

            if (_vbo == 0) _vbo = GL.GenBuffer();
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vbo);
            GL.BufferData(BufferTarget.ArrayBuffer, vertexData.Count * sizeof(float), vertexData.ToArray(), BufferUsageHint.StaticDraw);

            int strideBytes = CubeData.VertexStride * sizeof(float); // Now 8 * 4 = 32 bytes

            // Position attribute (location = 0)
            GL.EnableVertexAttribArray(0);
            // 3 floats, starting at offset 0
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, strideBytes, 0);

            // Normal attribute (location = 1)
            GL.EnableVertexAttribArray(1);
            // 3 floats, starting after Position (3 floats), so offset is 3 * sizeof(float)
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, false, strideBytes, 3 * sizeof(float)); // Corrected offset

            // TexCoord attribute (location = 2)
            GL.EnableVertexAttribArray(2);
            // 2 floats, starting after Position (3) and Normal (3), so offset is 6 * sizeof(float)
            GL.VertexAttribPointer(2, 2, VertexAttribPointerType.Float, false, strideBytes, 6 * sizeof(float)); // Corrected offset

            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);

            _isDirty = false;
        }

        // Draw method (MUST be called from the main/OpenGL thread)
        public void Draw()
        {
            if (!IsReadyToDraw) return;

            GL.BindVertexArray(_vao);
            GL.DrawArrays(PrimitiveType.Triangles, 0, _vertexCount);
            GL.BindVertexArray(0);
        }

        // Dispose OpenGL buffers (MUST be called from the main/OpenGL thread)
        private void DisposeBuffers()
        {
            if (_vbo != 0)
            {
                GL.DeleteBuffer(_vbo);
                _vbo = 0;
            }
            if (_vao != 0)
            {
                GL.DeleteVertexArray(_vao);
                _vao = 0;
            }
            _vertexCount = 0;
            _isInitialized = false;
            _isDirty = true;
        }

        // Dispose method (MUST be called from the main/OpenGL thread)
        public void Dispose()
        {
            DisposeBuffers();
        }
    }
}
